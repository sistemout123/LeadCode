<?php

namespace Database\Seeders;

use App\Models\Category;
use App\Models\Problem;
use Illuminate\Database\Seeder;

class ProblemSeeder extends Seeder
{
    public function run(): void
    {
        $cats = Category::pluck('id', 'slug');

        foreach ($this->getProblems($cats) as $i => $p) {
            $p['order'] = $i + 1;
            Problem::updateOrCreate(
                ['slug' => $p['slug']],
                $p
            );
        }
    }

    private function getProblems($c): array
    {
        return array_merge(
            $this->easyProblems($c),
            $this->mediumProblems($c),
            $this->hardProblems($c),
        );
    }

    private function easyProblems($c): array
    {
        return [
            [
                'category_id' => $c['arrays'],
                'title' => 'Two Sum',
                'slug' => 'two-sum',
                'difficulty' => 'easy',
                'time_limit_minutes' => 15,
                'xp_reward' => 10,
                'description' => "# Two Sum\n\nGiven an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.\n\nYou may assume that each input would have **exactly one solution**, and you may not use the same element twice.\n\n## Example\n```\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9\n```",
                'starter_code' => "function twoSum(nums, target) {\n  // Your code here\n}",
                'solution_code' => "function twoSum(nums, target) {\n  const map = new Map();\n  for (let i = 0; i < nums.length; i++) {\n    const complement = target - nums[i];\n    if (map.has(complement)) {\n      return [map.get(complement), i];\n    }\n    map.set(nums[i], i);\n  }\n  return [];\n}",
                'explanation' => "## Solução: Hash Map\n\n1. Criamos um Map para armazenar valores já vistos\n2. Para cada elemento, calculamos o complemento (target - nums[i])\n3. Se o complemento já está no Map, encontramos o par\n4. Senão, adicionamos o elemento atual ao Map\n\n**Complexidade:** O(n) tempo, O(n) espaço",
                'hints' => ['Pense em como verificar rapidamente se um complemento existe', 'Use um Hash Map para lookup O(1)'],
                'test_cases' => [['input' => ['nums' => [2, 7, 11, 15], 'target' => 9], 'output' => [0, 1]], ['input' => ['nums' => [3, 2, 4], 'target' => 6], 'output' => [1, 2]]],
                'constraints' => '2 ≤ nums.length ≤ 10⁴',
                'tags' => ['hash-map'],
            ],
            [
                'category_id' => $c['strings'],
                'title' => 'Reverse String',
                'slug' => 'reverse-string',
                'difficulty' => 'easy',
                'time_limit_minutes' => 10,
                'xp_reward' => 10,
                'description' => "# Reverse String\n\nWrite a function that reverses a string. The input string is given as an array of characters `s`.\n\nYou must do this by modifying the input array **in-place** with O(1) extra memory.\n\n## Example\n```\nInput: s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n```",
                'starter_code' => "function reverseString(s) {\n  // Your code here\n}",
                'solution_code' => "function reverseString(s) {\n  let left = 0, right = s.length - 1;\n  while (left < right) {\n    [s[left], s[right]] = [s[right], s[left]];\n    left++;\n    right--;\n  }\n}",
                'explanation' => "## Solução: Two Pointers\n\n1. Use dois ponteiros: um no início, outro no final\n2. Troque os elementos nas posições left e right\n3. Mova os ponteiros em direção ao centro\n\n**Complexidade:** O(n) tempo, O(1) espaço",
                'hints' => ['Use dois ponteiros', 'Swap in-place'],
                'test_cases' => [['input' => ['s' => ['h', 'e', 'l', 'l', 'o']], 'output' => ['o', 'l', 'l', 'e', 'h']]],
                'constraints' => '1 ≤ s.length ≤ 10⁵',
                'tags' => ['two-pointer'],
            ],
            [
                'category_id' => $c['strings'],
                'title' => 'Valid Palindrome',
                'slug' => 'valid-palindrome',
                'difficulty' => 'easy',
                'time_limit_minutes' => 15,
                'xp_reward' => 10,
                'description' => "# Valid Palindrome\n\nA phrase is a palindrome if, after converting all uppercase letters to lowercase and removing all non-alphanumeric characters, it reads the same forward and backward.\n\n## Example\n```\nInput: s = \"A man, a plan, a canal: Panama\"\nOutput: true\n```",
                'starter_code' => "function isPalindrome(s) {\n  // Your code here\n}",
                'solution_code' => "function isPalindrome(s) {\n  const cleaned = s.toLowerCase().replace(/[^a-z0-9]/g, '');\n  let left = 0, right = cleaned.length - 1;\n  while (left < right) {\n    if (cleaned[left] !== cleaned[right]) return false;\n    left++; right--;\n  }\n  return true;\n}",
                'explanation' => "## Solução: Clean + Two Pointers\n\n1. Limpe a string (lowercase, remova não-alfanuméricos)\n2. Use two pointers para comparar de fora para dentro\n\n**Complexidade:** O(n) tempo, O(n) espaço",
                'hints' => ['Primeiro normalize a string', 'Compare caracteres de fora para dentro'],
                'test_cases' => [['input' => ['s' => 'A man, a plan, a canal: Panama'], 'output' => true]],
                'constraints' => '1 ≤ s.length ≤ 2 × 10⁵',
                'tags' => ['two-pointer', 'string'],
            ],
            [
                'category_id' => $c['arrays'],
                'title' => 'Contains Duplicate',
                'slug' => 'contains-duplicate',
                'difficulty' => 'easy',
                'time_limit_minutes' => 10,
                'xp_reward' => 10,
                'description' => "# Contains Duplicate\n\nGiven an integer array `nums`, return `true` if any value appears at least twice, and `false` if every element is distinct.\n\n## Example\n```\nInput: nums = [1,2,3,1]\nOutput: true\n```",
                'starter_code' => "function containsDuplicate(nums) {\n  // Your code here\n}",
                'solution_code' => "function containsDuplicate(nums) {\n  return new Set(nums).size !== nums.length;\n}",
                'explanation' => "## Solução: Set\n\nUm Set remove duplicatas automaticamente. Se o tamanho do Set for diferente do array original, existem duplicatas.\n\n**Complexidade:** O(n) tempo, O(n) espaço",
                'hints' => ['Sets não permitem duplicatas', 'Compare tamanhos'],
                'test_cases' => [['input' => ['nums' => [1, 2, 3, 1]], 'output' => true], ['input' => ['nums' => [1, 2, 3, 4]], 'output' => false]],
                'constraints' => '1 ≤ nums.length ≤ 10⁵',
                'tags' => ['hash-set'],
            ],
            [
                'category_id' => $c['stack-queue'],
                'title' => 'Valid Parentheses',
                'slug' => 'valid-parentheses',
                'difficulty' => 'easy',
                'time_limit_minutes' => 15,
                'xp_reward' => 10,
                'description' => "# Valid Parentheses\n\nGiven a string `s` containing just the characters `(`, `)`, `{`, `}`, `[` and `]`, determine if the input string is valid.\n\n## Example\n```\nInput: s = \"()[]{}\"\nOutput: true\n```",
                'starter_code' => "function isValid(s) {\n  // Your code here\n}",
                'solution_code' => "function isValid(s) {\n  const stack = [];\n  const map = { ')': '(', '}': '{', ']': '[' };\n  for (const c of s) {\n    if (map[c]) {\n      if (stack.pop() !== map[c]) return false;\n    } else {\n      stack.push(c);\n    }\n  }\n  return stack.length === 0;\n}",
                'explanation' => "## Solução: Stack\n\n1. Use uma pilha para rastrear parênteses de abertura\n2. Para cada fechamento, verifique se corresponde ao topo da pilha\n3. No final, a pilha deve estar vazia\n\n**Complexidade:** O(n) tempo, O(n) espaço",
                'hints' => ['Use uma Stack', 'Mapeie cada fechamento ao seu par de abertura'],
                'test_cases' => [['input' => ['s' => '()[]{}'], 'output' => true], ['input' => ['s' => '(]'], 'output' => false]],
                'constraints' => '1 ≤ s.length ≤ 10⁴',
                'tags' => ['stack'],
            ],
            [
                'category_id' => $c['linked-lists'],
                'title' => 'Merge Two Sorted Lists',
                'slug' => 'merge-two-sorted-lists',
                'difficulty' => 'easy',
                'time_limit_minutes' => 20,
                'xp_reward' => 15,
                'description' => "# Merge Two Sorted Lists\n\nMerge two sorted linked lists and return it as a sorted list.\n\n## Example\n```\nInput: l1 = [1,2,4], l2 = [1,3,4]\nOutput: [1,1,2,3,4,4]\n```",
                'starter_code' => "function mergeTwoLists(l1, l2) {\n  // Your code here\n}",
                'solution_code' => "function mergeTwoLists(l1, l2) {\n  const dummy = { val: 0, next: null };\n  let current = dummy;\n  while (l1 && l2) {\n    if (l1.val <= l2.val) {\n      current.next = l1; l1 = l1.next;\n    } else {\n      current.next = l2; l2 = l2.next;\n    }\n    current = current.next;\n  }\n  current.next = l1 || l2;\n  return dummy.next;\n}",
                'explanation' => "## Solução: Dummy Node + Iteração\n\n1. Crie um nó dummy como ponto de partida\n2. Compare os nós das duas listas, adicionando o menor\n3. Quando uma lista acabar, conecte o restante da outra\n\n**Complexidade:** O(n+m) tempo, O(1) espaço",
                'hints' => ['Use um nó dummy para simplificar', 'Compare e avance o ponteiro da lista com menor valor'],
                'test_cases' => [['input' => ['l1' => [1, 2, 4], 'l2' => [1, 3, 4]], 'output' => [1, 1, 2, 3, 4, 4]]],
                'constraints' => '0 ≤ list.length ≤ 50',
                'tags' => ['linked-list', 'merge'],
            ],
            [
                'category_id' => $c['arrays'],
                'title' => 'Best Time to Buy and Sell Stock',
                'slug' => 'best-time-to-buy-sell-stock',
                'difficulty' => 'easy',
                'time_limit_minutes' => 15,
                'xp_reward' => 10,
                'description' => "# Best Time to Buy and Sell Stock\n\nFind the maximum profit from buying and selling one share of stock.\n\n## Example\n```\nInput: prices = [7,1,5,3,6,4]\nOutput: 5 (buy at 1, sell at 6)\n```",
                'starter_code' => "function maxProfit(prices) {\n  // Your code here\n}",
                'solution_code' => "function maxProfit(prices) {\n  let minPrice = Infinity, maxProfit = 0;\n  for (const price of prices) {\n    minPrice = Math.min(minPrice, price);\n    maxProfit = Math.max(maxProfit, price - minPrice);\n  }\n  return maxProfit;\n}",
                'explanation' => "## Solução: Track Minimum\n\n1. Mantenha o menor preço visto até agora\n2. Para cada preço, calcule o lucro potencial\n3. Atualize o lucro máximo\n\n**Complexidade:** O(n) tempo, O(1) espaço",
                'hints' => ['Rastreie o preço mínimo visto', 'Compare o lucro atual com o máximo'],
                'test_cases' => [['input' => ['prices' => [7, 1, 5, 3, 6, 4]], 'output' => 5]],
                'constraints' => '1 ≤ prices.length ≤ 10⁵',
                'tags' => ['greedy'],
            ],
            [
                'category_id' => $c['sorting-searching'],
                'title' => 'Binary Search',
                'slug' => 'binary-search',
                'difficulty' => 'easy',
                'time_limit_minutes' => 10,
                'xp_reward' => 10,
                'description' => "# Binary Search\n\nGiven a sorted array and a target value, return the index if found. If not, return -1.\n\n## Example\n```\nInput: nums = [-1,0,3,5,9,12], target = 9\nOutput: 4\n```",
                'starter_code' => "function search(nums, target) {\n  // Your code here\n}",
                'solution_code' => "function search(nums, target) {\n  let left = 0, right = nums.length - 1;\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (nums[mid] === target) return mid;\n    if (nums[mid] < target) left = mid + 1;\n    else right = mid - 1;\n  }\n  return -1;\n}",
                'explanation' => "## Solução: Binary Search clássico\n\n1. Mantenha ponteiros left e right\n2. Calcule mid e compare com target\n3. Ajuste os ponteiros baseado na comparação\n\n**Complexidade:** O(log n) tempo, O(1) espaço",
                'hints' => ['Divida o espaço de busca pela metade', 'Cuidado com o cálculo do mid'],
                'test_cases' => [['input' => ['nums' => [-1, 0, 3, 5, 9, 12], 'target' => 9], 'output' => 4]],
                'constraints' => '1 ≤ nums.length ≤ 10⁴',
                'tags' => ['binary-search'],
            ],
            [
                'category_id' => $c['dynamic-programming'],
                'title' => 'Climbing Stairs',
                'slug' => 'climbing-stairs',
                'difficulty' => 'easy',
                'time_limit_minutes' => 15,
                'xp_reward' => 10,
                'description' => "# Climbing Stairs\n\nYou are climbing a staircase. It takes `n` steps to reach the top. Each time you can climb 1 or 2 steps. How many distinct ways can you climb to the top?\n\n## Example\n```\nInput: n = 3\nOutput: 3 (1+1+1, 1+2, 2+1)\n```",
                'starter_code' => "function climbStairs(n) {\n  // Your code here\n}",
                'solution_code' => "function climbStairs(n) {\n  if (n <= 2) return n;\n  let prev = 1, curr = 2;\n  for (let i = 3; i <= n; i++) {\n    [prev, curr] = [curr, prev + curr];\n  }\n  return curr;\n}",
                'explanation' => "## Solução: Fibonacci iterativo\n\nÉ essencialmente a sequência de Fibonacci: f(n) = f(n-1) + f(n-2)\n\n**Complexidade:** O(n) tempo, O(1) espaço",
                'hints' => ['Perceba o padrão de Fibonacci', 'Não precisa de array, apenas 2 variáveis'],
                'test_cases' => [['input' => ['n' => 3], 'output' => 3], ['input' => ['n' => 5], 'output' => 8]],
                'constraints' => '1 ≤ n ≤ 45',
                'tags' => ['fibonacci', 'dp'],
            ],
            [
                'category_id' => $c['linked-lists'],
                'title' => 'Linked List Cycle',
                'slug' => 'linked-list-cycle',
                'difficulty' => 'easy',
                'time_limit_minutes' => 15,
                'xp_reward' => 10,
                'description' => "# Linked List Cycle\n\nGiven `head`, determine if the linked list has a cycle in it.\n\n## Example\n```\nInput: head = [3,2,0,-4], pos = 1\nOutput: true (tail connects to node index 1)\n```",
                'starter_code' => "function hasCycle(head) {\n  // Your code here\n}",
                'solution_code' => "function hasCycle(head) {\n  let slow = head, fast = head;\n  while (fast && fast.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n    if (slow === fast) return true;\n  }\n  return false;\n}",
                'explanation' => "## Solução: Floyd's Tortoise and Hare\n\nDois ponteiros: slow (1 passo) e fast (2 passos). Se há ciclo, eles se encontram.\n\n**Complexidade:** O(n) tempo, O(1) espaço",
                'hints' => ['Use dois ponteiros com velocidades diferentes', 'Se fast alcançar slow, há ciclo'],
                'test_cases' => [['input' => ['head' => [3, 2, 0, -4], 'pos' => 1], 'output' => true]],
                'constraints' => '0 ≤ list.length ≤ 10⁴',
                'tags' => ['two-pointer', 'linked-list'],
            ],
            [
                'category_id' => $c['linked-lists'],
                'title' => 'Reverse Linked List',
                'slug' => 'reverse-linked-list',
                'difficulty' => 'easy',
                'time_limit_minutes' => 15,
                'xp_reward' => 10,
                'description' => "# Reverse Linked List\n\nGiven the head of a singly linked list, reverse the list, and return the reversed list.\n\n## Example\n```\nInput: [1,2,3,4,5]\nOutput: [5,4,3,2,1]\n```",
                'starter_code' => "function reverseList(head) {\n  // Your code here\n}",
                'solution_code' => "function reverseList(head) {\n  let prev = null, curr = head;\n  while (curr) {\n    const next = curr.next;\n    curr.next = prev;\n    prev = curr;\n    curr = next;\n  }\n  return prev;\n}",
                'explanation' => "## Solução: Iterativa com 3 ponteiros\n\nMantemos prev, curr e next. A cada passo invertemos o ponteiro.\n\n**Complexidade:** O(n) tempo, O(1) espaço",
                'hints' => ['Use 3 ponteiros: prev, curr, next', 'Inverta o ponteiro next de cada nó'],
                'test_cases' => [['input' => ['head' => [1, 2, 3, 4, 5]], 'output' => [5, 4, 3, 2, 1]]],
                'constraints' => '0 ≤ list.length ≤ 5000',
                'tags' => ['linked-list'],
            ],
            [
                'category_id' => $c['trees'],
                'title' => 'Maximum Depth of Binary Tree',
                'slug' => 'maximum-depth-binary-tree',
                'difficulty' => 'easy',
                'time_limit_minutes' => 10,
                'xp_reward' => 10,
                'description' => "# Maximum Depth of Binary Tree\n\nGiven the root of a binary tree, return its maximum depth.\n\n## Example\n```\nInput: root = [3,9,20,null,null,15,7]\nOutput: 3\n```",
                'starter_code' => "function maxDepth(root) {\n  // Your code here\n}",
                'solution_code' => "function maxDepth(root) {\n  if (!root) return 0;\n  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n}",
                'explanation' => "## Solução: Recursão (DFS)\n\nA profundidade máxima é 1 + o máximo entre a profundidade da subárvore esquerda e direita.\n\n**Complexidade:** O(n) tempo, O(h) espaço (h = altura)",
                'hints' => ['Caso base: nó null = profundidade 0', 'Recursão: 1 + max(left, right)'],
                'test_cases' => [['input' => ['root' => [3, 9, 20, null, null, 15, 7]], 'output' => 3]],
                'constraints' => '0 ≤ nodes ≤ 10⁴',
                'tags' => ['tree', 'dfs', 'recursion'],
            ],
            [
                'category_id' => $c['trees'],
                'title' => 'Symmetric Tree',
                'slug' => 'symmetric-tree',
                'difficulty' => 'easy',
                'time_limit_minutes' => 15,
                'xp_reward' => 10,
                'description' => "# Symmetric Tree\n\nGiven the root of a binary tree, check whether it is a mirror of itself.\n\n## Example\n```\nInput: root = [1,2,2,3,4,4,3]\nOutput: true\n```",
                'starter_code' => "function isSymmetric(root) {\n  // Your code here\n}",
                'solution_code' => "function isSymmetric(root) {\n  function isMirror(t1, t2) {\n    if (!t1 && !t2) return true;\n    if (!t1 || !t2) return false;\n    return t1.val === t2.val && isMirror(t1.left, t2.right) && isMirror(t1.right, t2.left);\n  }\n  return isMirror(root, root);\n}",
                'explanation' => "## Solução: Recursão com espelhamento\n\nComparamos as subárvores espelhadas: left.left com right.right e left.right com right.left.\n\n**Complexidade:** O(n) tempo, O(n) espaço",
                'hints' => ['Compare subárvores espelhadas', 'left.left deve ser igual a right.right'],
                'test_cases' => [['input' => ['root' => [1, 2, 2, 3, 4, 4, 3]], 'output' => true]],
                'constraints' => '1 ≤ nodes ≤ 1000',
                'tags' => ['tree', 'recursion'],
            ],
            [
                'category_id' => $c['math-logic'],
                'title' => 'Single Number',
                'slug' => 'single-number',
                'difficulty' => 'easy',
                'time_limit_minutes' => 10,
                'xp_reward' => 10,
                'description' => "# Single Number\n\nGiven a non-empty array where every element appears twice except for one, find that single one.\n\n## Example\n```\nInput: nums = [4,1,2,1,2]\nOutput: 4\n```",
                'starter_code' => "function singleNumber(nums) {\n  // Your code here\n}",
                'solution_code' => "function singleNumber(nums) {\n  return nums.reduce((a, b) => a ^ b, 0);\n}",
                'explanation' => "## Solução: XOR\n\nXOR de um número consigo mesmo é 0. XOR com 0 retorna o número. Todos os pares se cancelam.\n\n**Complexidade:** O(n) tempo, O(1) espaço",
                'hints' => ['XOR tem propriedades interessantes: a^a=0, a^0=a', 'Use reduce com XOR'],
                'test_cases' => [['input' => ['nums' => [4, 1, 2, 1, 2]], 'output' => 4]],
                'constraints' => '1 ≤ nums.length ≤ 3 × 10⁴',
                'tags' => ['bit-manipulation', 'xor'],
            ],
        ];
    }

    private function mediumProblems($c): array
    {
        return [
            [
                'category_id' => $c['arrays'],
                'title' => 'Maximum Subarray',
                'slug' => 'maximum-subarray',
                'difficulty' => 'medium',
                'time_limit_minutes' => 20,
                'xp_reward' => 20,
                'description' => "# Maximum Subarray\n\nFind the contiguous subarray with the largest sum.\n\n## Example\n```\nInput: [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6 ([4,-1,2,1])\n```",
                'starter_code' => "function maxSubArray(nums) {\n  // Your code here\n}",
                'solution_code' => "function maxSubArray(nums) {\n  let maxSum = nums[0], currentSum = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    currentSum = Math.max(nums[i], currentSum + nums[i]);\n    maxSum = Math.max(maxSum, currentSum);\n  }\n  return maxSum;\n}",
                'explanation' => "## Solução: Kadane's Algorithm\n\nPara cada posição decidimos: começar novo subarray ou estender o atual.\n\n**Complexidade:** O(n) tempo, O(1) espaço",
                'hints' => ['Kadane: max(nums[i], currentSum + nums[i])'],
                'test_cases' => [['input' => ['nums' => [-2, 1, -3, 4, -1, 2, 1, -5, 4]], 'output' => 6]],
                'constraints' => '1 ≤ nums.length ≤ 10⁵',
                'tags' => ['kadane', 'dp'],
            ],
            [
                'category_id' => $c['hash-tables'],
                'title' => 'Group Anagrams',
                'slug' => 'group-anagrams',
                'difficulty' => 'medium',
                'time_limit_minutes' => 20,
                'xp_reward' => 20,
                'description' => "# Group Anagrams\n\nGroup strings that are anagrams of each other.\n\n## Example\n```\nInput: [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]\n```",
                'starter_code' => "function groupAnagrams(strs) {\n  // Your code here\n}",
                'solution_code' => "function groupAnagrams(strs) {\n  const map = new Map();\n  for (const s of strs) {\n    const key = s.split('').sort().join('');\n    if (!map.has(key)) map.set(key, []);\n    map.get(key).push(s);\n  }\n  return [...map.values()];\n}",
                'explanation' => "## Solução: Sort como chave do Map\n\nAnagramas têm a mesma representação quando ordenados. Use isso como chave.\n\n**Complexidade:** O(n * k log k) tempo",
                'hints' => ['Anagramas ordenados são iguais', 'Use a string ordenada como chave'],
                'test_cases' => [['input' => ['strs' => ['eat', 'tea', 'tan', 'ate', 'nat', 'bat']], 'output' => [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]]],
                'constraints' => '1 ≤ strs.length ≤ 10⁴',
                'tags' => ['hash-map', 'sorting'],
            ],
            [
                'category_id' => $c['arrays'],
                'title' => '3Sum',
                'slug' => 'three-sum',
                'difficulty' => 'medium',
                'time_limit_minutes' => 25,
                'xp_reward' => 25,
                'description' => "# 3Sum\n\nFind all unique triplets in the array which give the sum of zero.\n\n## Example\n```\nInput: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]\n```",
                'starter_code' => "function threeSum(nums) {\n  // Your code here\n}",
                'solution_code' => "function threeSum(nums) {\n  nums.sort((a, b) => a - b);\n  const result = [];\n  for (let i = 0; i < nums.length - 2; i++) {\n    if (i > 0 && nums[i] === nums[i-1]) continue;\n    let left = i + 1, right = nums.length - 1;\n    while (left < right) {\n      const sum = nums[i] + nums[left] + nums[right];\n      if (sum === 0) {\n        result.push([nums[i], nums[left], nums[right]]);\n        while (nums[left] === nums[left+1]) left++;\n        while (nums[right] === nums[right-1]) right--;\n        left++; right--;\n      } else if (sum < 0) left++;\n      else right--;\n    }\n  }\n  return result;\n}",
                'explanation' => "## Solução: Sort + Two Pointers\n\n1. Ordene o array\n2. Fixe um elemento e use two pointers para os outros dois\n3. Skip duplicatas\n\n**Complexidade:** O(n²) tempo, O(1) espaço extra",
                'hints' => ['Ordene primeiro', 'Reduza para Two Sum com two pointers', 'Pule duplicatas'],
                'test_cases' => [['input' => ['nums' => [-1, 0, 1, 2, -1, -4]], 'output' => [[-1, -1, 2], [-1, 0, 1]]]],
                'constraints' => '3 ≤ nums.length ≤ 3000',
                'tags' => ['two-pointer', 'sorting'],
            ],
            [
                'category_id' => $c['arrays'],
                'title' => 'Container With Most Water',
                'slug' => 'container-with-most-water',
                'difficulty' => 'medium',
                'time_limit_minutes' => 20,
                'xp_reward' => 20,
                'description' => "# Container With Most Water\n\nFind two lines that together with the x-axis forms a container that holds the most water.\n\n## Example\n```\nInput: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49\n```",
                'starter_code' => "function maxArea(height) {\n  // Your code here\n}",
                'solution_code' => "function maxArea(height) {\n  let left = 0, right = height.length - 1, max = 0;\n  while (left < right) {\n    const area = Math.min(height[left], height[right]) * (right - left);\n    max = Math.max(max, area);\n    if (height[left] < height[right]) left++;\n    else right--;\n  }\n  return max;\n}",
                'explanation' => "## Solução: Two Pointers (greedy)\n\nComece com o container mais largo e mova o ponteiro com menor altura.\n\n**Complexidade:** O(n) tempo, O(1) espaço",
                'hints' => ['Comece de fora para dentro', 'Mova o ponteiro com menor altura'],
                'test_cases' => [['input' => ['height' => [1, 8, 6, 2, 5, 4, 8, 3, 7]], 'output' => 49]],
                'constraints' => '2 ≤ n ≤ 10⁵',
                'tags' => ['two-pointer', 'greedy'],
            ],
            [
                'category_id' => $c['strings'],
                'title' => 'Longest Substring Without Repeating Characters',
                'slug' => 'longest-substring-no-repeat',
                'difficulty' => 'medium',
                'time_limit_minutes' => 25,
                'xp_reward' => 25,
                'description' => "# Longest Substring Without Repeating Characters\n\nFind the length of the longest substring without repeating characters.\n\n## Example\n```\nInput: s = \"abcabcbb\"\nOutput: 3 (\"abc\")\n```",
                'starter_code' => "function lengthOfLongestSubstring(s) {\n  // Your code here\n}",
                'solution_code' => "function lengthOfLongestSubstring(s) {\n  const set = new Set();\n  let left = 0, max = 0;\n  for (let right = 0; right < s.length; right++) {\n    while (set.has(s[right])) {\n      set.delete(s[left]);\n      left++;\n    }\n    set.add(s[right]);\n    max = Math.max(max, right - left + 1);\n  }\n  return max;\n}",
                'explanation' => "## Solução: Sliding Window\n\nUse uma janela deslizante com Set para rastrear caracteres únicos.\n\n**Complexidade:** O(n) tempo, O(min(m,n)) espaço",
                'hints' => ['Use sliding window', 'Mantenha um Set de caracteres na janela'],
                'test_cases' => [['input' => ['s' => 'abcabcbb'], 'output' => 3]],
                'constraints' => '0 ≤ s.length ≤ 5 × 10⁴',
                'tags' => ['sliding-window', 'hash-set'],
            ],
            [
                'category_id' => $c['linked-lists'],
                'title' => 'Add Two Numbers',
                'slug' => 'add-two-numbers',
                'difficulty' => 'medium',
                'time_limit_minutes' => 25,
                'xp_reward' => 20,
                'description' => "# Add Two Numbers\n\nTwo non-empty linked lists represent two non-negative integers in reverse order. Add them and return as a linked list.\n\n## Example\n```\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8] (342 + 465 = 807)\n```",
                'starter_code' => "function addTwoNumbers(l1, l2) {\n  // Your code here\n}",
                'solution_code' => "function addTwoNumbers(l1, l2) {\n  const dummy = { val: 0, next: null };\n  let curr = dummy, carry = 0;\n  while (l1 || l2 || carry) {\n    const sum = (l1?.val || 0) + (l2?.val || 0) + carry;\n    carry = Math.floor(sum / 10);\n    curr.next = { val: sum % 10, next: null };\n    curr = curr.next;\n    l1 = l1?.next; l2 = l2?.next;\n  }\n  return dummy.next;\n}",
                'explanation' => "## Solução: Simulação de adição\n\nSome dígito a dígito com carry, como adição manual.\n\n**Complexidade:** O(max(m,n)) tempo, O(max(m,n)) espaço",
                'hints' => ['Simule adição manual com carry', 'Use dummy node'],
                'test_cases' => [['input' => ['l1' => [2, 4, 3], 'l2' => [5, 6, 4]], 'output' => [7, 0, 8]]],
                'constraints' => '1 ≤ nodes ≤ 100',
                'tags' => ['linked-list', 'math'],
            ],
            [
                'category_id' => $c['trees'],
                'title' => 'Validate Binary Search Tree',
                'slug' => 'validate-bst',
                'difficulty' => 'medium',
                'time_limit_minutes' => 20,
                'xp_reward' => 20,
                'description' => "# Validate Binary Search Tree\n\nDetermine if a given binary tree is a valid BST.\n\n## Example\n```\nInput: root = [2,1,3]\nOutput: true\n```",
                'starter_code' => "function isValidBST(root) {\n  // Your code here\n}",
                'solution_code' => "function isValidBST(root, min = -Infinity, max = Infinity) {\n  if (!root) return true;\n  if (root.val <= min || root.val >= max) return false;\n  return isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max);\n}",
                'explanation' => "## Solução: Recursão com limites\n\nCada nó deve estar dentro de um range válido [min, max].\n\n**Complexidade:** O(n) tempo, O(n) espaço",
                'hints' => ['Cada nó tem um range válido', 'Passe min/max como parâmetros'],
                'test_cases' => [['input' => ['root' => [2, 1, 3]], 'output' => true]],
                'constraints' => '1 ≤ nodes ≤ 10⁴',
                'tags' => ['tree', 'bst', 'recursion'],
            ],
            [
                'category_id' => $c['dynamic-programming'],
                'title' => 'Coin Change',
                'slug' => 'coin-change',
                'difficulty' => 'medium',
                'time_limit_minutes' => 25,
                'xp_reward' => 25,
                'description' => "# Coin Change\n\nReturn the fewest number of coins needed to make up the amount. Return -1 if impossible.\n\n## Example\n```\nInput: coins = [1,5,10,25], amount = 30\nOutput: 2 (25 + 5)\n```",
                'starter_code' => "function coinChange(coins, amount) {\n  // Your code here\n}",
                'solution_code' => "function coinChange(coins, amount) {\n  const dp = new Array(amount + 1).fill(Infinity);\n  dp[0] = 0;\n  for (let i = 1; i <= amount; i++) {\n    for (const coin of coins) {\n      if (coin <= i) dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n    }\n  }\n  return dp[amount] === Infinity ? -1 : dp[amount];\n}",
                'explanation' => "## Solução: Bottom-up DP\n\ndp[i] = mínimo de moedas para fazer o valor i.\n\n**Complexidade:** O(amount × coins) tempo, O(amount) espaço",
                'hints' => ['DP bottom-up: dp[i] = min moedas para valor i', 'Para cada valor, tente cada moeda'],
                'test_cases' => [['input' => ['coins' => [1, 5, 10, 25], 'amount' => 30], 'output' => 2]],
                'constraints' => '1 ≤ coins.length ≤ 12',
                'tags' => ['dp', 'bottom-up'],
            ],
            [
                'category_id' => $c['graphs'],
                'title' => 'Number of Islands',
                'slug' => 'number-of-islands',
                'difficulty' => 'medium',
                'time_limit_minutes' => 25,
                'xp_reward' => 25,
                'description' => "# Number of Islands\n\nCount the number of islands in a 2D grid. An island is surrounded by water ('0') and formed by connecting adjacent lands ('1') horizontally or vertically.\n\n## Example\n```\nInput: grid = [[\"1\",\"1\",\"0\"],[\"1\",\"0\",\"0\"],[\"0\",\"0\",\"1\"]]\nOutput: 2\n```",
                'starter_code' => "function numIslands(grid) {\n  // Your code here\n}",
                'solution_code' => "function numIslands(grid) {\n  let count = 0;\n  function dfs(i, j) {\n    if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] === '0') return;\n    grid[i][j] = '0';\n    dfs(i+1,j); dfs(i-1,j); dfs(i,j+1); dfs(i,j-1);\n  }\n  for (let i = 0; i < grid.length; i++)\n    for (let j = 0; j < grid[0].length; j++)\n      if (grid[i][j] === '1') { count++; dfs(i, j); }\n  return count;\n}",
                'explanation' => "## Solução: DFS Flood Fill\n\nPara cada '1' encontrado, incrementa o contador e \"afunda\" a ilha inteira com DFS.\n\n**Complexidade:** O(m×n) tempo, O(m×n) espaço",
                'hints' => ['DFS para explorar cada ilha', 'Marque células visitadas como 0'],
                'test_cases' => [['input' => ['grid' => [['1', '1', '0'], ['1', '0', '0'], ['0', '0', '1']]], 'output' => 2]],
                'constraints' => '1 ≤ m, n ≤ 300',
                'tags' => ['dfs', 'graph', 'matrix'],
            ],
            [
                'category_id' => $c['arrays'],
                'title' => 'Product of Array Except Self',
                'slug' => 'product-of-array-except-self',
                'difficulty' => 'medium',
                'time_limit_minutes' => 20,
                'xp_reward' => 20,
                'description' => "# Product of Array Except Self\n\nReturn an array where each element is the product of all elements except itself. No division allowed.\n\n## Example\n```\nInput: [1,2,3,4]\nOutput: [24,12,8,6]\n```",
                'starter_code' => "function productExceptSelf(nums) {\n  // Your code here\n}",
                'solution_code' => "function productExceptSelf(nums) {\n  const n = nums.length, result = new Array(n).fill(1);\n  let prefix = 1;\n  for (let i = 0; i < n; i++) { result[i] = prefix; prefix *= nums[i]; }\n  let suffix = 1;\n  for (let i = n - 1; i >= 0; i--) { result[i] *= suffix; suffix *= nums[i]; }\n  return result;\n}",
                'explanation' => "## Solução: Prefix × Suffix\n\nCalcula prefix products da esquerda e suffix da direita.\n\n**Complexidade:** O(n) tempo, O(1) espaço extra",
                'hints' => ['Sem divisão: use prefix e suffix products', 'Duas passagens: esquerda→direita, direita→esquerda'],
                'test_cases' => [['input' => ['nums' => [1, 2, 3, 4]], 'output' => [24, 12, 8, 6]]],
                'constraints' => '2 ≤ nums.length ≤ 10⁵',
                'tags' => ['prefix-sum'],
            ],
            [
                'category_id' => $c['stack-queue'],
                'title' => 'Min Stack',
                'slug' => 'min-stack',
                'difficulty' => 'medium',
                'time_limit_minutes' => 20,
                'xp_reward' => 20,
                'description' => "# Min Stack\n\nDesign a stack that supports push, pop, top, and retrieving the minimum element in O(1).\n\n## Example\n```\nMinStack minStack = new MinStack();\nminStack.push(-2); minStack.push(0); minStack.push(-3);\nminStack.getMin(); // -3\nminStack.pop();\nminStack.getMin(); // -2\n```",
                'starter_code' => "class MinStack {\n  constructor() {\n    // Your code here\n  }\n  push(val) {}\n  pop() {}\n  top() {}\n  getMin() {}\n}",
                'solution_code' => "class MinStack {\n  constructor() {\n    this.stack = [];\n    this.minStack = [];\n  }\n  push(val) {\n    this.stack.push(val);\n    this.minStack.push(Math.min(val, this.minStack.length ? this.minStack[this.minStack.length-1] : val));\n  }\n  pop() { this.stack.pop(); this.minStack.pop(); }\n  top() { return this.stack[this.stack.length - 1]; }\n  getMin() { return this.minStack[this.minStack.length - 1]; }\n}",
                'explanation' => "## Solução: Duas pilhas\n\nUma pilha auxiliar rastreia o mínimo em cada nível.\n\n**Complexidade:** O(1) para todas as operações",
                'hints' => ['Use uma segunda pilha para mínimos', 'Cada nível da minStack armazena o mín até aquele ponto'],
                'test_cases' => [],
                'constraints' => '-2³¹ ≤ val ≤ 2³¹ - 1',
                'tags' => ['stack', 'design'],
            ],
        ];
    }

    private function hardProblems($c): array
    {
        return [
            [
                'category_id' => $c['linked-lists'],
                'title' => 'Merge K Sorted Lists',
                'slug' => 'merge-k-sorted-lists',
                'difficulty' => 'hard',
                'time_limit_minutes' => 35,
                'xp_reward' => 40,
                'description' => "# Merge K Sorted Lists\n\nMerge k sorted linked lists into one sorted linked list.\n\n## Example\n```\nInput: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]\n```",
                'starter_code' => "function mergeKLists(lists) {\n  // Your code here\n}",
                'solution_code' => "function mergeKLists(lists) {\n  if (!lists.length) return null;\n  function merge2(l1, l2) {\n    const d = {val:0, next:null}; let c = d;\n    while (l1 && l2) {\n      if (l1.val <= l2.val) { c.next = l1; l1 = l1.next; }\n      else { c.next = l2; l2 = l2.next; }\n      c = c.next;\n    }\n    c.next = l1 || l2; return d.next;\n  }\n  while (lists.length > 1) {\n    const merged = [];\n    for (let i = 0; i < lists.length; i += 2)\n      merged.push(merge2(lists[i], lists[i+1] || null));\n    lists = merged;\n  }\n  return lists[0];\n}",
                'explanation' => "## Solução: Divide and Conquer\n\nMerge pares de listas repetidamente até restar uma.\n\n**Complexidade:** O(N log k) tempo",
                'hints' => ['Divide and conquer: merge pares', 'Reutilize merge de 2 listas'],
                'test_cases' => [['input' => ['lists' => [[1, 4, 5], [1, 3, 4], [2, 6]]], 'output' => [1, 1, 2, 3, 4, 4, 5, 6]]],
                'constraints' => '0 ≤ k ≤ 10⁴',
                'tags' => ['linked-list', 'divide-conquer', 'heap'],
            ],
            [
                'category_id' => $c['arrays'],
                'title' => 'Trapping Rain Water',
                'slug' => 'trapping-rain-water',
                'difficulty' => 'hard',
                'time_limit_minutes' => 35,
                'xp_reward' => 40,
                'description' => "# Trapping Rain Water\n\nGiven elevation map, compute how much water it can trap after raining.\n\n## Example\n```\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\n```",
                'starter_code' => "function trap(height) {\n  // Your code here\n}",
                'solution_code' => "function trap(height) {\n  let left = 0, right = height.length - 1;\n  let leftMax = 0, rightMax = 0, water = 0;\n  while (left < right) {\n    if (height[left] < height[right]) {\n      height[left] >= leftMax ? leftMax = height[left] : water += leftMax - height[left];\n      left++;\n    } else {\n      height[right] >= rightMax ? rightMax = height[right] : water += rightMax - height[right];\n      right--;\n    }\n  }\n  return water;\n}",
                'explanation' => "## Solução: Two Pointers\n\nMantenha máximos da esquerda e direita. A água em cada posição é limitada pelo menor máximo.\n\n**Complexidade:** O(n) tempo, O(1) espaço",
                'hints' => ['A água é limitada pela menor parede', 'Two pointers de fora para dentro'],
                'test_cases' => [['input' => ['height' => [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]], 'output' => 6]],
                'constraints' => '0 ≤ n ≤ 2 × 10⁴',
                'tags' => ['two-pointer', 'stack'],
            ],
            [
                'category_id' => $c['graphs'],
                'title' => 'Word Search',
                'slug' => 'word-search',
                'difficulty' => 'hard',
                'time_limit_minutes' => 30,
                'xp_reward' => 35,
                'description' => "# Word Search\n\nGiven a 2D board and a word, find if the word exists in the grid. Can move horizontally or vertically.\n\n## Example\n```\nInput: board = [[\"A\",\"B\"],[\"C\",\"D\"]], word = \"ABDC\"\nOutput: true\n```",
                'starter_code' => "function exist(board, word) {\n  // Your code here\n}",
                'solution_code' => "function exist(board, word) {\n  const rows = board.length, cols = board[0].length;\n  function dfs(r, c, i) {\n    if (i === word.length) return true;\n    if (r < 0 || c < 0 || r >= rows || c >= cols || board[r][c] !== word[i]) return false;\n    const temp = board[r][c];\n    board[r][c] = '#';\n    const found = dfs(r+1,c,i+1) || dfs(r-1,c,i+1) || dfs(r,c+1,i+1) || dfs(r,c-1,i+1);\n    board[r][c] = temp;\n    return found;\n  }\n  for (let r = 0; r < rows; r++)\n    for (let c = 0; c < cols; c++)\n      if (dfs(r, c, 0)) return true;\n  return false;\n}",
                'explanation' => "## Solução: DFS + Backtracking\n\nPara cada célula, tente DFS. Marque visitados e faça backtrack.\n\n**Complexidade:** O(m×n×4^L) tempo",
                'hints' => ['DFS com backtracking', 'Marque visitados temporariamente'],
                'test_cases' => [['input' => ['board' => [['A', 'B'], ['C', 'D']], 'word' => 'ABDC'], 'output' => true]],
                'constraints' => '1 ≤ m, n ≤ 6',
                'tags' => ['backtracking', 'dfs', 'matrix'],
            ],
            [
                'category_id' => $c['dynamic-programming'],
                'title' => 'Longest Increasing Subsequence',
                'slug' => 'longest-increasing-subsequence',
                'difficulty' => 'hard',
                'time_limit_minutes' => 30,
                'xp_reward' => 35,
                'description' => "# Longest Increasing Subsequence\n\nReturn the length of the longest strictly increasing subsequence.\n\n## Example\n```\nInput: nums = [10,9,2,5,3,7,101,18]\nOutput: 4 ([2,3,7,101])\n```",
                'starter_code' => "function lengthOfLIS(nums) {\n  // Your code here\n}",
                'solution_code' => "function lengthOfLIS(nums) {\n  const tails = [];\n  for (const num of nums) {\n    let lo = 0, hi = tails.length;\n    while (lo < hi) {\n      const mid = (lo + hi) >> 1;\n      tails[mid] < num ? lo = mid + 1 : hi = mid;\n    }\n    tails[lo] = num;\n  }\n  return tails.length;\n}",
                'explanation' => "## Solução: DP + Binary Search (Patience Sorting)\n\nMantenha um array de tails e use binary search para posicionar cada elemento.\n\n**Complexidade:** O(n log n) tempo, O(n) espaço",
                'hints' => ['DP clássico é O(n²), mas há solução O(n log n)', 'Patience sorting com binary search'],
                'test_cases' => [['input' => ['nums' => [10, 9, 2, 5, 3, 7, 101, 18]], 'output' => 4]],
                'constraints' => '1 ≤ nums.length ≤ 2500',
                'tags' => ['dp', 'binary-search'],
            ],
            [
                'category_id' => $c['hash-tables'],
                'title' => 'LRU Cache',
                'slug' => 'lru-cache',
                'difficulty' => 'hard',
                'time_limit_minutes' => 40,
                'xp_reward' => 50,
                'description' => "# LRU Cache\n\nDesign a data structure that follows LRU (Least Recently Used) eviction policy.\n\n## Example\n```\nLRUCache cache = new LRUCache(2);\ncache.put(1, 1); cache.put(2, 2);\ncache.get(1);    // returns 1\ncache.put(3, 3); // evicts key 2\ncache.get(2);    // returns -1\n```",
                'starter_code' => "class LRUCache {\n  constructor(capacity) {\n    // Your code here\n  }\n  get(key) {}\n  put(key, value) {}\n}",
                'solution_code' => "class LRUCache {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.cache = new Map();\n  }\n  get(key) {\n    if (!this.cache.has(key)) return -1;\n    const val = this.cache.get(key);\n    this.cache.delete(key);\n    this.cache.set(key, val);\n    return val;\n  }\n  put(key, value) {\n    this.cache.delete(key);\n    this.cache.set(key, value);\n    if (this.cache.size > this.capacity) {\n      this.cache.delete(this.cache.keys().next().value);\n    }\n  }\n}",
                'explanation' => "## Solução: Map (ordered)\n\nJavaScript Map mantém ordem de inserção. Delete + re-insert move para o final (most recent). O primeiro é o least recent.\n\n**Complexidade:** O(1) para get e put",
                'hints' => ['JS Map mantém ordem de inserção', 'Delete e re-insert atualiza a posição', 'O primeiro elemento é o LRU'],
                'test_cases' => [],
                'constraints' => '1 ≤ capacity ≤ 3000',
                'tags' => ['design', 'hash-map', 'linked-list'],
            ],
        ];
    }
}
